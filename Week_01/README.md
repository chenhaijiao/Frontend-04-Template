# 学习笔记  
## 第一周
>参考网址  
>>[目录文件为空报错](https://www.jianshu.com/p/40ffdd0654f4)  
[注意pull使用](https://www.cnblogs.com/alex-415/p/6912294.html)  
[整合本地仓库与远程仓库](https://blog.csdn.net/u012145252/article/details/80628451)  
#### 当在GitHub中fork了一个项目，如何建立本地仓库与远程仓库的连接  
1. 先下载项目到本地  
2. 保证对项目内容先不做更改  
3. 结合上面两个网址步骤去做  
    >1. git init //初始化仓库  
    >2. git add .(文件name) //添加文件到本地仓库  
    >3. git commit -m "first commit" //添加文件描述信息  
    >4. git remote add origin + 远程仓库地址 //链接远程仓库，创建主分支  
    >5. git pull origin master --allow-unrelated-histories// 把本地仓库的变化连接到远程仓库主分支  
    >6. git push origin master:master //把本地仓库的文件推送到远程仓库  
- [x] 课上代码消化
- [ ] 五子棋算法优化
- [ ] 前端知识架构
- [x] 红绿灯小结练习代码提交
- [ ] 完整看一遍 JavaScript 文档，doing
- [ ] 完整看一遍 HTML 文档
- [ ] 完整看一遍 CSS 文档
- [ ] 知识点整理

# 整理知识架构中....
基础不是夯实，还没完整的看过有关手册、文档，感觉很多东西不知道，下面是一些碎碎念 
## 函数 
1. js中匿名函数的不断重复使用和声明函数的不断重复使用，性能上有差距吗？
### 函数表达式  
2. 
  ```
  const factorial = function fac(n) {return n<2 ? 1 : n*fac(n-1)};
  console.log(factorial(3));
  ```  
  这段代码中function必须传递fac函数名吗？  答：不一定，可以不传递函数名，其实觉得没必要这样使用
### 函数作用域  和 函数堆栈
3. 注意函数作用域，与代码声明的的顺序，一般来说函数先声明，再声明变量和表达式
4. 函数本身也是对象，对象可以有方法，函数内部也可以声明方法，注意 apply() 的使用,还没看这是啥
5. 一个函数可以调用自身，以函数表达式为例
    + factorial()
    + fac()
    + argument.callee() ES5禁止在严格模式下使用此属性，不懂严格模式是啥？
6. 在不使用函数递归的情况下，用函数堆栈来解决递归问题？怎么弄
### 函数嵌套和闭包
7. 闭包函数调用不加括号怎么传参，应该说还要多理解一下----还是需要理解，去看看闭包函数的妙用可能就懂到底用来干啥了，保密操作吗？不能被试探和测试到的那种
    + inside能够保存x变量的值，每次重新调用的时候就会重新创建一次这个闭包，当不在引用此闭包函数之后，才会释放内存  
    + 因为不能直接引用，平时难以跟踪和检查
    ```
    function outside(x) {
    function inside(y) {
        return x + y;
      }
      return inside;
    }
    fn_inside = outside(3); // 可以这样想：给一个函数，使它的值加3
    result = fn_inside(5); // returns 8
    result1 = outside(3)(5); // returns 8
    ```
8. 函数作用域链，只能说写函数嵌套的时候一定注意调用关系！！！
9. 函数内的命名冲突，作用域链是最近的优先级最高，相当于命名冲突变量的闭包内的优先级最高{inside, outside, 全局变量}-----大概只有巧用妙用的时候才会这样来用，最好是避免函数内部的命名冲突，有时候可能编译器不靠谱呢？？？
10. 才知道闭包是 JavaScript 最强大的特性之一，真的以为就是简单的 java 内部类似的
11. 闭包的产生：当内部函数以某一种形式被外部函数作用域访问时，一个闭包就产生了！！！！----那这样说的话，其实闭包可以很常见，但是很少使用吧
12. 越看越觉得就是 java 的内部类，保护一些特定的值的时候需要用内部类来获取的那种
13. 闭包使用的优点：安全保密，感觉没啥了
14. 闭包函数的陷阱：当闭包函数对冲突变量赋值的时候，到底是给哪个变量赋值了呢 答：就给闭包内的变量赋值，但是不能再用外部的变量，只能用闭包函数传进来的冲突变量；
### 使用arguments对象
15. 感觉可以接受，但注意只是一个“类数组对象”,确实包含length属性，但是很多数组对象的属性并不包含，更多信息详细参考 Function 一栏  
### 函数参数
16. 从ES6之后，有了默认参数个剩余参数两个概念
    1. 在 JavaScript 中函数参数的默认值是 undefined ，注意 JavaScript 中 undefined 和 null 的区别
    2. 过去一般是先判断测试参数是不是为 undefined (大概相当于分配了空间，但是没有赋值)，如果是 undefined 就传递参数值  
    3. 现在直接使用默认参数，不需要再多一步判断，且可以在函数头设置默认参数-----但是自己重新传值会不会覆盖掉，还需要去测试 答：会被覆盖掉，所以称为默认参数，hhhh
17. 剩余参数：允许将不确定的参数表示为数组
### 箭头函数
18. 相比函数表达式有更短的语法并以词法的形式绑定 --- 还需要多探索妙用
    + 更简洁的函数
    + this 的引用 --- 所以会产生挺多陷阱，注意检查
        + 在构造函数中是一个全新的对象
        + 在严格模式下未定义----严格模式到底是啥，还是没有弄清楚
        + 在作为“对象方法”调用的函数中指向这个对象 --- 以面向对象的编程风格，所以说 JavaScript 到底是面向对象还是基于对象那篇文章，等多看几遍文档再写
        + 下面这段代码的意思领略了，但是注释有点看不懂，主要是看不懂严格模式和非严格模式的问题
    ```
    function Person() {
      // 构造函数Person()将`this`定义为自身
      this.age = 0;

      setInterval(function growUp() {
        // 在非严格模式下，growUp()函数将`this`定义为“全局对象”，
        // 这与Person()定义的`this`不同，
        // 所以下面的语句不会起到预期的效果。
        this.age++;
      }, 1000);
    }
    var p = new Person();
    ```


